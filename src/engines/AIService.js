import { UI_CONSTANTS } from '../utils/constants'
import { logger } from '../utils/logger'

/**
 * AIService handles AI-powered lyric refinement using Google Gemini API.
 * 
 * SECURITY NOTE: API keys are stored in localStorage (user-provided).
 * For production, consider using a backend proxy to protect API keys.
 */
class AIService {
    constructor() {
        this.apiKey = ''
        this.model = 'gemini-1.5-flash'
        this.defaultTimeout = UI_CONSTANTS.TIMEOUT.DEFAULT
        this.activeRequests = new Map() // Track active requests for cancellation
    }

    setApiKey(key) {
        this.apiKey = key
    }

    setModel(model) {
        this.model = model
    }

    /**
     * Cancel an active request by ID
     * @param {string} requestId - Request ID to cancel
     */
    cancelRequest(requestId) {
        const request = this.activeRequests.get(requestId)
        if (request && request.controller) {
            request.controller.abort()
            this.activeRequests.delete(requestId)
        }
    }

    /**
     * Cancel all active requests
     */
    cancelAllRequests() {
        this.activeRequests.forEach((request, id) => {
            if (request.controller) {
                request.controller.abort()
            }
        })
        this.activeRequests.clear()
    }

    /**
     * Make a fetch request with timeout and proper error handling
     * @private
     * @param {string} url - Request URL
     * @param {Object} options - Fetch options
     * @param {number} timeout - Timeout in milliseconds
     * @param {string} requestId - Optional request ID for cancellation
     * @returns {Promise<Response>}
     */
    async makeRequest(url, options = {}, timeout = this.defaultTimeout, requestId = null) {
        const controller = new AbortController()
        const timeoutId = setTimeout(() => controller.abort(), timeout)

        // Store request for potential cancellation
        if (requestId) {
            this.activeRequests.set(requestId, { controller, timeoutId })
        }

        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            })
            clearTimeout(timeoutId)
            if (requestId) {
                this.activeRequests.delete(requestId)
            }
            return response
        } catch (error) {
            clearTimeout(timeoutId)
            if (requestId) {
                this.activeRequests.delete(requestId)
            }
            if (error.name === 'AbortError') {
                throw new Error(`Request timeout after ${timeout}ms`)
            }
            throw error
        }
    }

    /**
     * Build Gemini API URL and headers
     * Note: Gemini API supports both header and query param auth.
     * Using query param for compatibility, but headers would be more secure.
     * @private
     */
    buildRequestConfig(endpoint) {
        const baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models'
        // Using query param as Gemini API requires it for v1beta endpoint
        // TODO: Consider backend proxy for production to hide API keys
        const url = `${baseUrl}/${this.model}:${endpoint}?key=${encodeURIComponent(this.apiKey)}`
        
        const headers = {
            'Content-Type': 'application/json'
        }

        return { url, headers }
    }

    /**
     * Refine the parsed tokens using AI to ensure correct readings in context.
     * @param {string} fullText - The original song lyrics.
     * @param {Array} parsedLines - The tokens generated by the NLP engine.
     */
    async refineReadings(fullText, parsedLines) {
        if (!this.apiKey) {
            throw new Error('Gemini API Key is required for AI refinement.')
        }

        // Prepare a structured version of the parsed data for the AI to review
        const flatTokens = parsedLines.flat().filter(t => t.type === 'kanji')

        if (flatTokens.length === 0) return parsedLines

        const prompt = `
            You are an expert Japanese linguist specializing in song lyrics and creative readings (Ateji).
            
            GOAL: Correct the furigana (readings) for the provided lyrics to match the OFFICIAL song recording exactly.

            FULL LYRICS:
            """
            ${fullText}
            """

            TOKENS TO VERIFY:
            ${JSON.stringify(flatTokens.map(t => ({ id: t.id, text: t.text, kuroshiro_reading: t.reading })), null, 2)}

            INSTRUCTIONS:
            1. SEARCH for the official lyrics of this song ("${fullText.substring(0, 30).replace(/\n/g, ' ')}..."). 
            2. Identify the specific reading the singer uses. Lyrics often use "Ateji" (e.g., "未来" read as "asu", "本気" read as "maji").
            3. Compare the "kuroshiro_reading" (auto-generated) with the OFFICIAL reading.
            4. Return the corrected data for ALL tokens.

            OUTPUT FORMAT (Strict JSON):
            { 
                "enrichments": [ 
                    { 
                        "id": "token-id", 
                        "reading": "verified_hiragana_reading", 
                        "definition": "concise meaning in context",
                        "notes": "Note if Ateji or special reading" 
                    } 
                ],
                "translations": [ "Line 1 English", "Line 2 English", ... ]
            }
        `

        try {
            const { url, headers } = this.buildRequestConfig('generateContent')
            const response = await this.makeRequest(url, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    contents: [{
                        parts: [{ text: prompt }]
                    }],
                    tools: [{
                        googleSearch: {} // Enable search for context verification
                    }]
                })
            }, UI_CONSTANTS.TIMEOUT.AI_REFINEMENT) // Longer timeout for AI refinement

            if (!response.ok) {
                const errorText = await response.text();
                let errorData = {};
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) { }
                throw new Error(errorData.error?.message || `AI API error: ${response.status} - ${errorText.substring(0, 100)}`);
            }

            const data = await response.json()

            if (!data.candidates || !data.candidates[0]?.content?.parts?.[0]?.text) {
                throw new Error('AI Refinement returned an empty or invalid response')
            }

            let resultText = data.candidates[0].content.parts[0].text
            // Clean up Markdown if AI wrapped JSON in code blocks
            resultText = resultText.replace(/^```json\n?/, '').replace(/\n?```$/, '').trim();

            let result;
            try {
                result = JSON.parse(resultText)
            } catch (e) {
                logger.error('Failed to parse AI response as JSON. Raw text:', resultText)
                throw new Error('AI Refinement returned invalid formatted data')
            }

            if (result.enrichments && Array.isArray(result.enrichments)) {
                // Apply enrichments back to the parsedLines
                const enrichmentMap = new Map(
                    result.enrichments.map(e => [e.id, e])
                )

                let updatedCount = 0
                const updatedLines = parsedLines.map(line =>
                    line.map(token => {
                        if (enrichmentMap.has(token.id)) {
                            updatedCount++
                            const data = enrichmentMap.get(token.id)
                            return {
                                ...token,
                                reading: data.reading, // Update reading
                                definition: data.definition, // Add definition
                                notes: data.notes // Add usage notes
                            }
                        }
                        return token
                    })
                )

                logger.info(`AI Refinement: Enriched ${updatedCount} tokens. loaded ${result.translations?.length || 0} translations.`)
                return {
                    parsedLines: updatedLines,
                    translations: result.translations || []
                }
            }

            return { parsedLines, translations: [] }
        } catch (error) {
            logger.warn('AI Refinement Error:', error.message)
            // If AI fails (e.g., quota exceeded), fail gracefully and return original parsing
            return { parsedLines, translations: [] }
        }
    }

    /**
     * Fetch song details (lyrics and audio URL) using AI.
     * @param {string} title 
     * @param {string} artist 
     * @param {string} contextInfo
     * @returns {Promise<{lyrics: string, audioUrl: string}>}
     */
    async fetchSongDetails(title, artist, contextInfo = '') {
        if (!this.apiKey) {
            throw new Error('Gemini API Key is required.')
        }

        const prompt = `
            Task: Find the exact, OFFICIAL Japanese lyrics for the song below using Google Search.
            
            Target Song:
            Title: "${title}"
            Artist: "${artist}"
            ${contextInfo ? `Additional Context: "${contextInfo}"` : ''}

            CRITICAL INSTRUCTIONS:
            1. You MUST use the Google Search tool to verify the lyrics. Search for "${title} ${artist} 歌詞" or "${title} Japanese Lyrics".
            2. The lyrics MUST be in original JAPANESE SCRIPT (Kanji/Kana). 
            3. STRICTLY FORBIDDEN: Do NOT provide Romaji (Latin alphabet transliteration). If the search returns Romaji, keep searching for the Kanji version.
            4. If the song has English parts, keep them in English. But the Japanese parts MUST be in Japanese characters.
            5. Return "Lyrics not found" only if you absolutely cannot find the Japanese text.
            6. Output must be a pure JSON object.

            Output Schema:
            {
                "lyrics": "string (the full Japanese lyrics with \\n for line breaks)",
                "audioUrl": "optional string (direct audio/youtube link if found)"
            }
        `

        try {
            let response;
            try {
                // Attempt 1: Try with Google Search Grounding with HIGH threshold to force search
                const { url, headers } = this.buildRequestConfig('generateContent')
                response = await this.makeRequest(url, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        tools: [{
                            googleSearch: {} // Updated from googleSearchRetrieval based on API feedback
                        }]
                    })
                }, UI_CONSTANTS.TIMEOUT.AI_REFINEMENT)

                if (!response.ok) {
                    const statusText = await response.text();
                    logger.warn(`Search Grounding attempt failed (${response.status}):`, statusText);
                    throw new Error(`Search attempt failed with status: ${response.status}`);
                }
            } catch (e) {
                logger.warn('Google Search Grounding failed, skipping to simple fallback.', e)
                throw e; // Throw to outer catch to trigger Hail Mary directly
            }

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`AI API error: ${response.status}`);
            }

            const data = await response.json()
            if (!data.candidates || !data.candidates[0]?.content?.parts?.[0]?.text) {
                throw new Error('AI returned an empty response')
            }

            let resultText = data.candidates[0].content.parts[0].text
            // Clean up Markdown if AI wrapped JSON in code blocks
            const jsonMatch = resultText.match(/\{[\s\S]*\}/);

            // strict check: if no JSON structure is found, it's likely a conversational failure
            if (!jsonMatch) {
                throw new Error('No JSON found in AI response - triggering fallback.');
            }

            const jsonCandidate = jsonMatch[0];

            let result;
            try {
                result = JSON.parse(jsonCandidate)
            } catch (e) {
                logger.warn('Failed to parse AI response as JSON, falling back to raw text', resultText)
                result = { lyrics: resultText, audioUrl: '' }
            }

            // Check for soft failure (AI followed instructions to return "Lyrics not found")
            if (result.lyrics && result.lyrics.toLowerCase().includes('lyrics not found')) {
                throw new Error('AI returned "Lyrics not found" - triggering fallback.');
            }

            return result;
        } catch (error) {
            logger.error('AI Song Search Error:', error)

            // Final Hail Mary: If everything else failed (search error, strict fallback error), 
            // try one last basic request without any complex instructions or tools.
            try {
                const simplePrompt = `Provide the Japanese lyrics for "${title}" by "${artist}". Return ONLY the lyrics as plain text. Do NOT provide Romaji transliteration.`;
                const { url, headers } = this.buildRequestConfig('generateContent')
                const response = await this.makeRequest(url, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: simplePrompt }] }]
                    })
                }, UI_CONSTANTS.TIMEOUT.DEFAULT);
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) return { lyrics: text, audioUrl: '' };
            } catch (finalError) {
                logger.error('Final fallback failed', finalError);
            }

            throw error
        }
    }

    async findAudio(title, artist) {
        if (!this.apiKey) return null;

        const prompt = `
            Task: Find the official YouTube audio/video URL for the song "${title}" by "${artist}".
            
            Instructions:
            1. Search for the official music video or official lyric video on YouTube.
            2. If official video is not found, find a high-quality "topic" channel upload or valid cover.
            3. Return the standard YouTube URL (e.g., https://www.youtube.com/watch?v=...).
            4. Output strict JSON.

            Output Schema:
            {
                "audioUrl": "string or null"
            }
        `;

        try {
            const { url, headers } = this.buildRequestConfig('generateContent')
            const response = await this.makeRequest(url, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    tools: [{ googleSearch: {} }]
                })
            }, UI_CONSTANTS.TIMEOUT.DEFAULT);

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) return null;

            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const result = JSON.parse(jsonMatch[0]);
                return result.audioUrl;
            }
            return null;
        } catch (error) {
            logger.warn('Audio search failed:', error);
            return null;
        }
    }
    async verifyToken(tokenText, contextLine, requestId = null) {
        if (!this.apiKey) return null;

        const complexPrompt = `
            Task: detailed analysis of the Japanese word/kanji "${tokenText}" in the context line: "${contextLine}".
            
            Instructions:
            1. Identify the likely reading (furigana) of "${tokenText}" in THIS context.
            2. Explain the meaning of "${tokenText}" in THIS context.
            3. Note any special pronunciation rules (e.g. lyrics-specific reading).
            
            Output Schema (JSON):
            {
                "reading": "hiragana",
                "definition": "concise english meaning",
                "notes": "explanation or nuance"
            }
        `;

        const makeVerificationRequest = async (prompt, useTools = true) => {
            const body = {
                contents: [{ parts: [{ text: prompt }] }],
                ...(useTools ? { tools: [{ googleSearch: {} }] } : {})
            };

            const { url, headers } = this.buildRequestConfig('generateContent')
            const response = await this.makeRequest(url, {
                method: 'POST',
                headers,
                body: JSON.stringify(body)
            }, UI_CONSTANTS.TIMEOUT.DEFAULT, requestId);

            if (!response.ok) throw new Error(`API Error: ${response.status}`);

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) throw new Error('Empty response');

            // Try to extract JSON
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
            throw new Error('No JSON found');
        };

        try {
            // Attempt 1: Full Context with Search
            return await makeVerificationRequest(complexPrompt, true);
        } catch (error) {
            logger.warn('Primary verification failed, retrying simple:', error);
            try {
                // Attempt 2: Simple Prompt (No Tools)
                const simplePrompt = `Identify the Japanese reading (Hiragana) and English meaning of "${tokenText}" in the context: "${contextLine}". Return JSON: {"reading": "...", "definition": "..."}`;
                return await makeVerificationRequest(simplePrompt, false);
            } catch (retryError) {
                logger.warn('Fallback verification failed:', retryError);
                return null;
            }
        }
    }

    /**
     * Generate English translations for lyrics lines.
     */
    async generateTranslations(lines) {
        if (!this.apiKey) return null;

        const linesText = lines.map((l, i) => `${i + 1}. ${l}`).join('\n');
        const prompt = `
            Translate the following Japanese song lyrics into English.
            Maintain the line-by-line structure.
            Return a JSON array of strings matching the line count.
            
            Lyrics:
            ${linesText}
            
            Output Schema:
            ["Line 1 translation", "Line 2 translation", ...]
        `;

        try {
            const { url, headers } = this.buildRequestConfig('generateContent')
            const response = await this.makeRequest(url, {
                method: 'POST',
                headers,
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            }, UI_CONSTANTS.TIMEOUT.DEFAULT);

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) return null;

            const jsonMatch = text.match(/\[[\s\S]*\]/);
            if (jsonMatch) return JSON.parse(jsonMatch[0]);
            return null;
        } catch (e) {
            logger.warn('Translation generation failed', e);
            return null;
        }
    }
}


export const aiService = new AIService()
export default AIService
