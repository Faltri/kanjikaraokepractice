/**
 * AIService handles AI-powered lyric refinement using Google Gemini API.
 */
class AIService {
    constructor() {
        this.apiKey = ''
        this.model = 'gemini-1.5-flash'
    }

    setApiKey(key) {
        this.apiKey = key
    }

    setModel(model) {
        this.model = model
    }

    /**
     * Refine the parsed tokens using AI to ensure correct readings in context.
     * @param {string} fullText - The original song lyrics.
     * @param {Array} parsedLines - The tokens generated by the NLP engine.
     */
    async refineReadings(fullText, parsedLines) {
        if (!this.apiKey) {
            throw new Error('Gemini API Key is required for AI refinement.')
        }

        // Prepare a structured version of the parsed data for the AI to review
        const flatTokens = parsedLines.flat().filter(t => t.type === 'kanji')

        if (flatTokens.length === 0) return parsedLines

        const prompt = `
            You are an expert Japanese linguist. I am building a lyrics practice app.
            I have parsed the following Japanese lyrics using a basic NLP engine, which might have incorrect readings (furigana) for some Kanji, especially in the context of song lyrics where readings can be non-standard or context-dependent.

            FULL LYRICS:
            """
            ${fullText}
            """

            CURRENT KANJI TOKENS AND READINGS:
            ${JSON.stringify(flatTokens.map(t => ({ id: t.id, text: t.text, current_reading: t.reading })), null, 2)}

            Task:
            1. Search for the song using the provided lyrics to find an official source with furigana (readings) and meaning.
            2. Analyze EVERY Kanji token in the context of the song.
            3. For EACH Kanji token, provide:
               - The verified reading (furigana).
               - A concise English definition/meaning SPECIFIC to its usage in this lyric (e.g. if 'sora' is written with 'sky' kanji but means 'heavens', note that).
            4. PAY ATTENTION to potential reading errors (e.g. 'gen' vs 'i' for '言').
            5. Return a JSON object containing entries for ALL Kanji tokens representing the full song.
            6. ADDITIONALLY: Provide an English translation for EACH LINE of the lyrics (sequentially matching the non-empty lines).
            7. The format should be: { 
                "enrichments": [ { "id": "token-id", "reading": "...", "definition": "..." }, ... ],
                "translations": [ "Line 1 English", "Line 2 English", ... ]
            }
            8. Return ONLY the JSON object.
        `

        try {
            // ... (fetch logic) ...
            // Use v1beta for better model compatibility by default
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{ text: prompt }]
                    }],
                    tools: [{
                        googleSearch: {} // Enable search for context verification
                    }]
                })
            })

            if (!response.ok) {
                const errorText = await response.text();
                let errorData = {};
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) { }
                throw new Error(errorData.error?.message || `AI API error: ${response.status} - ${errorText.substring(0, 100)}`);
            }

            const data = await response.json()

            if (!data.candidates || !data.candidates[0]?.content?.parts?.[0]?.text) {
                throw new Error('AI Refinement returned an empty or invalid response')
            }

            let resultText = data.candidates[0].content.parts[0].text
            // Clean up Markdown if AI wrapped JSON in code blocks
            resultText = resultText.replace(/^```json\n?/, '').replace(/\n?```$/, '').trim();

            let result;
            try {
                result = JSON.parse(resultText)
            } catch (e) {
                console.error('Failed to parse AI response as JSON. Raw text:', resultText)
                throw new Error('AI Refinement returned invalid formatted data')
            }

            if (result.enrichments && Array.isArray(result.enrichments)) {
                // Apply enrichments back to the parsedLines
                const enrichmentMap = new Map(
                    result.enrichments.map(e => [e.id, e])
                )

                let updatedCount = 0
                const updatedLines = parsedLines.map(line =>
                    line.map(token => {
                        if (enrichmentMap.has(token.id)) {
                            updatedCount++
                            const data = enrichmentMap.get(token.id)
                            return {
                                ...token,
                                reading: data.reading, // Update reading
                                definition: data.definition // Add definition
                            }
                        }
                        return token
                    })
                )

                console.log(`AI Refinement: Enriched ${updatedCount} tokens. loaded ${result.translations?.length || 0} translations.`)
                return {
                    parsedLines: updatedLines,
                    translations: result.translations || []
                }
            }

            return { parsedLines, translations: [] }
        } catch (error) {
            console.warn('AI Refinement Error:', error.message)
            // If AI fails (e.g., quota exceeded), fail gracefully and return original parsing
            return { parsedLines, translations: [] }
        }
    }

    /**
     * Fetch song details (lyrics and audio URL) using AI.
     * @param {string} title 
     * @param {string} artist 
     * @param {string} contextInfo
     * @returns {Promise<{lyrics: string, audioUrl: string}>}
     */
    async fetchSongDetails(title, artist, contextInfo = '') {
        if (!this.apiKey) {
            throw new Error('Gemini API Key is required.')
        }

        const prompt = `
            Task: Find the exact, OFFICIAL Japanese lyrics for the song below using Google Search.
            
            Target Song:
            Title: "${title}"
            Artist: "${artist}"
            ${contextInfo ? `Additional Context: "${contextInfo}"` : ''}

            CRITICAL INSTRUCTIONS:
            1. You MUST use the Google Search tool to verify the lyrics. Search for "${title} ${artist} 歌詞" or "${title} Japanese Lyrics".
            2. The lyrics MUST be in original JAPANESE SCRIPT (Kanji/Kana). 
            3. STRICTLY FORBIDDEN: Do NOT provide Romaji (Latin alphabet transliteration). If the search returns Romaji, keep searching for the Kanji version.
            4. If the song has English parts, keep them in English. But the Japanese parts MUST be in Japanese characters.
            5. Return "Lyrics not found" only if you absolutely cannot find the Japanese text.
            6. Output must be a pure JSON object.

            Output Schema:
            {
                "lyrics": "string (the full Japanese lyrics with \\n for line breaks)",
                "audioUrl": "optional string (direct audio/youtube link if found)"
            }
        `

        try {
            let response;
            try {
                // Attempt 1: Try with Google Search Grounding with HIGH threshold to force search
                response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        tools: [{
                            googleSearch: {} // Updated from googleSearchRetrieval based on API feedback
                        }]
                    })
                })

                if (!response.ok) {
                    const statusText = await response.text();
                    console.warn(`Search Grounding attempt failed (${response.status}):`, statusText);
                    throw new Error(`Search attempt failed with status: ${response.status}`);
                }
            } catch (e) {
                console.warn('Google Search Grounding failed, skipping to simple fallback.', e)
                throw e; // Throw to outer catch to trigger Hail Mary directly
            }

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`AI API error: ${response.status}`);
            }

            const data = await response.json()
            if (!data.candidates || !data.candidates[0]?.content?.parts?.[0]?.text) {
                throw new Error('AI returned an empty response')
            }

            let resultText = data.candidates[0].content.parts[0].text
            // Clean up Markdown if AI wrapped JSON in code blocks
            const jsonMatch = resultText.match(/\{[\s\S]*\}/);

            // strict check: if no JSON structure is found, it's likely a conversational failure
            if (!jsonMatch) {
                throw new Error('No JSON found in AI response - triggering fallback.');
            }

            const jsonCandidate = jsonMatch[0];

            let result;
            try {
                result = JSON.parse(jsonCandidate)
            } catch (e) {
                console.warn('Failed to parse AI response as JSON, falling back to raw text', resultText)
                result = { lyrics: resultText, audioUrl: '' }
            }

            // Check for soft failure (AI followed instructions to return "Lyrics not found")
            if (result.lyrics && result.lyrics.toLowerCase().includes('lyrics not found')) {
                throw new Error('AI returned "Lyrics not found" - triggering fallback.');
            }

            return result;
        } catch (error) {
            console.error('AI Song Search Error:', error)

            // Final Hail Mary: If everything else failed (search error, strict fallback error), 
            // try one last basic request without any complex instructions or tools.
            try {
                const simplePrompt = `Provide the Japanese lyrics for "${title}" by "${artist}". Return ONLY the lyrics as plain text. Do NOT provide Romaji transliteration.`;
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: simplePrompt }] }]
                    })
                });
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) return { lyrics: text, audioUrl: '' };
            } catch (finalError) {
                console.error('Final fallback failed', finalError);
            }

            throw error
        }
    }

    async findAudio(title, artist) {
        if (!this.apiKey) return null;

        const prompt = `
            Task: Find a direct, playable audio URL (MP3, M4A, etc.) for the song "${title}" by "${artist}".
            
            Instructions:
            1. Search for official audio previews, Archive.org links, or open-source audio files.
            2. Do NOT provide YouTube pages or Spotify links (must be a direct file URL for an <audio> tag).
            3. If you can only find a YouTube Video URL, return that, but label it clearly.
            4. Output strict JSON.

            Output Schema:
            {
                "audioUrl": "string or null"
            }
        `;

        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    tools: [{ googleSearch: {} }]
                })
            });

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) return null;

            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const result = JSON.parse(jsonMatch[0]);
                return result.audioUrl;
            }
            return null;
        } catch (error) {
            console.warn('Audio search failed:', error);
            return null;
        }
    }
    async verifyToken(tokenText, contextLine) {
        if (!this.apiKey) return null;

        const prompt = `
            Task: detailed analysis of the Japanese word/kanji "${tokenText}" in the context line: "${contextLine}".
            
            Instructions:
            1. Identify the likely reading (furigana) of "${tokenText}" in THIS context.
            2. Explain the meaning of "${tokenText}" in THIS context.
            3. Note any special pronunciation rules (e.g. lyrics-specific reading).
            
            Output Schema (JSON):
            {
                "reading": "hiragana",
                "definition": "concise english meaning",
                "notes": "explanation or nuance"
            }
        `;

        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    tools: [{ googleSearch: {} }]
                })
            });

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) return null;

            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
            return null;
        } catch (error) {
            console.warn('Token verification failed:', error);
            return null;
        }
    }
}


export const aiService = new AIService()
export default AIService
